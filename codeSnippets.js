export const codeSnippets = [
    '#include <linux/module.h>',
    '#include <linux/kernel.h>',
    '#include <linux/init.h>',
    '#include <linux/fs.h>',
    '#include <linux/slab.h>',
    '#include <linux/uaccess.h>',
    '#include <linux/cdev.h>',
    '#include <linux/device.h>',
    'static dev_t dev_num;',
    'static struct cdev my_cdev;',
    'static struct class *my_class;',
    'static char *kernel_buffer;',
    'static int my_open(struct inode *inode, struct file *file) {',
    '    printk(KERN_INFO "Device opened\\n");',
    '    return 0;',
    '}',
    'static ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *offset) {',
    '    copy_to_user(buf, kernel_buffer, count);',
    '    printk(KERN_INFO "Data read from device\\n");',
    '    return count;',
    '}',
    'static ssize_t my_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) {',
    '    copy_from_user(kernel_buffer, buf, count);',
    '    printk(KERN_INFO "Data written to device\\n");',
    '    return count;',
    '}',
    'static int my_release(struct inode *inode, struct file *file) {',
    '    printk(KERN_INFO "Device closed\\n");',
    '    return 0;',
    '}',
    'static struct file_operations fops = {',
    '    .owner = THIS_MODULE,',
    '    .open = my_open,',
    '    .read = my_read,',
    '    .write = my_write,',
    '    .release = my_release,',
    '};',
    'static int __init my_module_init(void) {',
    '    alloc_chrdev_region(&dev_num, 0, 1, "my_device");',
    '    cdev_init(&my_cdev, &fops);',
    '    cdev_add(&my_cdev, dev_num, 1);',
    '    my_class = class_create(THIS_MODULE, "my_class");',
    '    device_create(my_class, NULL, dev_num, NULL, "my_device");',
    '    kernel_buffer = kmalloc(1024, GFP_KERNEL);',
    '    printk(KERN_INFO "Kernel module initialized\\n");',
    '    return 0;',
    '}',
    'static void __exit my_module_exit(void) {',
    '    kfree(kernel_buffer);',
    '    device_destroy(my_class, dev_num);',
    '    class_destroy(my_class);',
    '    unregister_chrdev_region(dev_num, 1);',
    '    printk(KERN_INFO "Kernel module exited\\n");',
    '}',
    'module_init(my_module_init);',
    'module_exit(my_module_exit);',
    'MODULE_LICENSE("GPL");',
    'MODULE_AUTHOR("Kernel Developer");',
    'MODULE_DESCRIPTION("Advanced Linux kernel module");',
    '// Additional realistic kernel code',
    '#include <linux/sched.h>',
    '#include <linux/mm.h>',
    'static void analyze_memory(void) {',
    '    struct task_struct *task;',
    '    for_each_process(task) {',
    '        printk(KERN_INFO "Process: %s, PID: %d, Memory: %lu\\n", task->comm, task->pid, task->mm->total_vm);',
    '    }',
    '}',
    'static void monitor_cpu(void) {',
    '    printk(KERN_INFO "CPU monitoring started\\n");',
    '    // Simulated CPU analysis logic',
    '}',
    'static void network_analysis(void) {',
    '    printk(KERN_INFO "Analyzing network packets\\n");',
    '    // Simulated network packet inspection logic',
    '}',
    'analyze_memory();',
    'monitor_cpu();',
    'network_analysis();'
];
